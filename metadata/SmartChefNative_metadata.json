"{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolLimitPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardDelayPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_exitPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenRecovered\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AdminTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBlockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBlockTime\",\"type\":\"uint256\"}],\"name\":\"BlockTimeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolLimitPerUser\",\"type\":\"uint256\"}],\"name\":\"NewPoolLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"NewRewardPerBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardDelayPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exitPeriod\",\"type\":\"uint256\"}],\"name\":\"PeriodsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"availableTime\",\"type\":\"uint256\"}],\"name\":\"WithdrawRequested\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"EXIT_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECISION_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_DELAY_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accTokenPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpointInterval\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"claimableView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyRewardWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executeWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundRewards\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseAPY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"getEstimatedAPY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawRequestTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalAvailableTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLocked_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"inExitPeriod\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canRequestWithdraw\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canExecuteWithdraw\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasUserLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isInExitPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"lockedView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLimitPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverWrongTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"requestWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_apyBps\",\"type\":\"uint256\"}],\"name\":\"setBaseAPY\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"setRewardPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"timeUntilUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"timeUntilWithdrawalAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAccruedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalActiveEffective\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInExitPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newBlockTime\",\"type\":\"uint256\"}],\"name\":\"updateBlockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardDelayPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_exitPeriod\",\"type\":\"uint256\"}],\"name\":\"updatePeriods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_hasUserLimit\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_poolLimitPerUser\",\"type\":\"uint256\"}],\"name\":\"updatePoolLimitPerUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"effectiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtClaimablePS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDurationBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawRequestBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delayedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delayedUnlockBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}],\"ReentrancyGuardReentrantCall()\":[{\"details\":\"Unauthorized reentrant call.\"}]},\"kind\":\"dev\",\"methods\":{\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Sliding-window vesting via accTokenPerShare checkpoints. - Users have a \\\"baseline\\\" per-share (debtClaimablePS). What\\u2019s claimable now is   E * (accPS_at(block - delay) - baseline). No writes are needed to *view* it. - We keep a small ring of checkpoints and INTERPOLATE between them for smooth vesting. - Early exits are DISALLOWED. Unlocked exits move stake into an exit queue; rewards   already streamed but inside the delay window keep vesting \\\"virtually\\\" and are captured   at request time into (delayedReward, delayedUnlockBlock) so users can still claim them   after they unlock, even though their stake stopped earning further.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/SmartChefNative.sol\":\"SmartChefNative\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\\n * consider using {ReentrancyGuardTransient} instead.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x11a5a79827df29e915a12740caf62fe21ebe27c08c9ae3e09abe9ee3ba3866d3\",\"license\":\"MIT\"},\"contracts/SmartChefNative.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\n/**\\n * Sliding-window vesting via accTokenPerShare checkpoints.\\n * - Users have a \\\"baseline\\\" per-share (debtClaimablePS). What\\u2019s claimable now is\\n *   E * (accPS_at(block - delay) - baseline). No writes are needed to *view* it.\\n * - We keep a small ring of checkpoints and INTERPOLATE between them for smooth vesting.\\n * - Early exits are DISALLOWED. Unlocked exits move stake into an exit queue; rewards\\n *   already streamed but inside the delay window keep vesting \\\"virtually\\\" and are captured\\n *   at request time into (delayedReward, delayedUnlockBlock) so users can still claim them\\n *   after they unlock, even though their stake stopped earning further.\\n */\\ncontract SmartChefNative is Ownable, ReentrancyGuard {\\n  // ---------------------------\\n  // User data\\n  // ---------------------------\\n  struct UserInfo {\\n    uint256 amount;              // principal\\n    uint256 effectiveAmount;     // amount * multiplier\\n    uint256 rewardDebt;          // for pendingReward()\\n    uint256 debtClaimablePS;     // baseline for sliding-window claimable view\\n    uint256 lockStartBlock;\\n    uint256 lockDuration;        // seconds\\n    uint256 lockDurationBlocks;  // derived from blockTime\\n    uint256 withdrawRequestBlock;\\n    uint256 withdrawalAmount;\\n\\n    // exiting portion's delayed pipeline snapshot (for unlocked exits)\\n    uint256 delayedReward;       // fixed sum that unlocks later\\n    uint256 delayedUnlockBlock;  // when delayedReward becomes claimable\\n  }\\n\\n  // ---------------------------\\n  // Config\\n  // ---------------------------\\n  uint256 public REWARD_DELAY_PERIOD = 10 minutes;\\n  uint256 public EXIT_PERIOD         = 10 minutes;\\n  uint256 public rewardPerBlock;\\n  uint256 public startBlock;\\n  uint256 public lastRewardBlock;\\n  uint256 public blockTime = 5; // seconds\\n\\n  bool     public hasUserLimit;\\n  uint256  public poolLimitPerUser;\\n  uint256  public PRECISION_FACTOR; // 1e12+ scale for per-share math (here 1e12)\\n\\n  // ---------------------------\\n  // Pool state\\n  // ---------------------------\\n  uint256 public accTokenPerShare;      // scaled by PRECISION_FACTOR\\n  uint256 public totalStaked;           // principal (includes exit)\\n  uint256 public totalActiveEffective;  // active effective (denominator)\\n  uint256 public totalInExitPeriod;     // principal in exit queue (not earning)\\n  uint256 public totalAccruedRewards;   // sum streamed into accPS\\n  uint256 public totalClaimedRewards;   // sum paid out\\n\\n  mapping(address => UserInfo) public userInfo;\\n\\n  // ---------------------------\\n  // Checkpoint ring for sliding window (accTokenPerShare timeline)\\n  // ---------------------------\\n  struct Checkpoint { uint64 blockNum; uint256 acc; }\\n  uint16 internal constant MAX_CHECKPOINTS = 256;\\n  mapping(uint16 => Checkpoint) internal _checkpoints;\\n  uint16 internal _cpHead;        // last written index\\n  uint16 internal _cpSize;        // number of valid checkpoints\\n  uint64 public  checkpointInterval = 6; // ~30s at 5s/block\\n  uint64 internal lastCheckpointBlock;\\n\\n  // ---------------------------\\n  // Events\\n  // ---------------------------\\n  event Deposit(address indexed user, uint256 amount, uint256 duration);\\n  event WithdrawRequested(address indexed user, uint256 amount, uint256 availableTime);\\n  event WithdrawExecuted(address indexed user, uint256 amount);\\n  event RewardClaimed(address indexed user, uint256 amount);\\n  event NewPoolLimit(uint256 poolLimitPerUser);\\n  event AdminTokenRecovery(address tokenRecovered, uint256 amount);\\n  event RewardsFunded(uint256 amount);\\n  event PeriodsUpdated(uint256 rewardDelayPeriod, uint256 exitPeriod);\\n  event NewRewardPerBlock(uint256 newRate);\\n  event BlockTimeUpdated(uint256 oldBlockTime, uint256 newBlockTime);\\n\\n  constructor(\\n    uint256 _poolLimitPerUser,\\n    uint256 _rewardDelayPeriod,\\n    uint256 _exitPeriod,\\n    uint256 _rewardPerBlock,\\n    uint256 _startBlock\\n  ) Ownable(msg.sender) {\\n    if (_poolLimitPerUser > 0) {\\n      hasUserLimit = true;\\n      poolLimitPerUser = _poolLimitPerUser;\\n    }\\n    REWARD_DELAY_PERIOD = _rewardDelayPeriod;\\n    EXIT_PERIOD         = _exitPeriod;\\n\\n    // Native has 18 decimals; target 30-decimal internal precision\\n    PRECISION_FACTOR = 10 ** (30 - 18);\\n\\n    rewardPerBlock  = _rewardPerBlock;\\n    startBlock      = _startBlock > block.number ? _startBlock : block.number;\\n    lastRewardBlock = startBlock;\\n\\n    lastCheckpointBlock = uint64(block.number);\\n    _pushCheckpoint(uint64(block.number), 0); // initial\\n  }\\n\\n  // ---------------------------\\n  // Internals: helpers\\n  // ---------------------------\\n  function _getBoostMultiplier(uint256 _duration) internal pure returns (uint256) {\\n    if (_duration == 10 minutes) return 1e18;\\n    if (_duration == 20 minutes) return 1500000000000000000; // 1.5e18\\n    revert(\\\"Invalid duration\\\");\\n  }\\n\\n  function _activePrincipal() internal view returns (uint256) {\\n    return totalStaked - totalInExitPeriod;\\n  }\\n\\n  function _activeEffective() internal view returns (uint256) {\\n    return totalActiveEffective;\\n  }\\n\\n  function _rewardBalance() internal view returns (uint256) {\\n    uint256 bal = address(this).balance;\\n    return bal > totalStaked ? bal - totalStaked : 0;\\n  }\\n\\n  // ---------------------------\\n  // Core staking\\n  // ---------------------------\\n  function deposit(uint256 _duration) external payable nonReentrant {\\n    require(_duration == 10 minutes || _duration == 20 minutes, \\\"Invalid duration\\\");\\n    UserInfo storage user = userInfo[msg.sender];\\n    uint256 _amount = msg.value;\\n    require(_amount > 0, \\\"Zero deposit\\\");\\n    require(user.withdrawRequestBlock == 0, \\\"In exit period\\\");\\n\\n    if (hasUserLimit) {\\n      require(_amount + user.amount <= poolLimitPerUser, \\\"Above limit\\\");\\n    }\\n\\n    _updatePool();\\n\\n    if (user.amount > 0) {\\n      _claimRewardsInternal(msg.sender); // pay any matured pipeline + move baseline\\n      require(_duration == user.lockDuration, \\\"Duration mismatch\\\");\\n    } else {\\n      user.lockDuration = _duration;\\n      // set baseline to delayed frontier now\\n      uint256 delayBlocks = REWARD_DELAY_PERIOD / blockTime;\\n      uint256 tBlock = block.number > delayBlocks ? block.number - delayBlocks : 0;\\n      user.debtClaimablePS = _accPSAtBlock(uint64(tBlock));\\n    }\\n\\n    uint256 mult = _getBoostMultiplier(_duration);\\n    uint256 addEff = (_amount * mult) / 1e18;\\n\\n    user.effectiveAmount += addEff;\\n    totalActiveEffective += addEff;\\n\\n    user.amount += _amount;\\n    totalStaked += _amount;\\n\\n    user.lockStartBlock     = block.number;\\n    user.lockDurationBlocks = _duration / blockTime;\\n\\n    user.rewardDebt = (user.effectiveAmount * accTokenPerShare) / PRECISION_FACTOR;\\n    emit Deposit(msg.sender, _amount, _duration);\\n  }\\n\\n  // Only allow withdrawal request when unlocked (NO EARLY EXITS)\\n  function requestWithdraw(uint256 _amount) external nonReentrant {\\n    UserInfo storage user = userInfo[msg.sender];\\n    require(_amount > 0 && user.amount >= _amount, \\\"Bad amount\\\");\\n    require(user.lockStartBlock > 0, \\\"No stake\\\");\\n    require(user.withdrawRequestBlock == 0, \\\"Already requested\\\");\\n    require(block.number >= user.lockStartBlock + user.lockDurationBlocks, \\\"Stake locked\\\");\\n\\n    _updatePool();\\n\\n    // Claim matured pipeline up to now BEFORE removing effective from denominator\\n    _claimRewardsInternal(msg.sender);\\n\\n    // Snapshot the delayed portion for the exiting amount so it can still mature and be claimed later.\\n    uint256 exitEffective = (_amount * _getBoostMultiplier(user.lockDuration)) / 1e18;\\n\\n    uint256 delayBlocks = REWARD_DELAY_PERIOD / blockTime;\\n    uint256 tBlock = block.number > delayBlocks ? block.number - delayBlocks : 0;\\n    uint256 accPast = _accPSAtBlock(uint64(tBlock));\\n    uint256 deltaPS = accTokenPerShare - accPast;\\n    if (deltaPS > 0) {\\n      uint256 exitLocked = (exitEffective * deltaPS) / PRECISION_FACTOR;\\n      user.delayedReward += exitLocked;\\n      user.delayedUnlockBlock = block.number + delayBlocks;\\n    }\\n\\n    // Remove from active\\n    user.effectiveAmount -= exitEffective;\\n    totalActiveEffective -= exitEffective;\\n\\n    // Move principal into exit queue\\n    user.withdrawRequestBlock = block.number;\\n    user.withdrawalAmount     = _amount;\\n    totalInExitPeriod        += _amount;\\n\\n    user.rewardDebt = (user.effectiveAmount * accTokenPerShare) / PRECISION_FACTOR;\\n\\n    uint256 availableTime = block.timestamp + EXIT_PERIOD;\\n    emit WithdrawRequested(msg.sender, _amount, availableTime);\\n  }\\n\\n  function executeWithdraw() external nonReentrant {\\n    _updatePool();\\n    // Auto-claim any matured rewards (unlocked snapshot and sliding-window portion)\\n    // so users receive vested rewards alongside principal withdrawal.\\n    _claimRewardsInternal(msg.sender);\\n    UserInfo storage user = userInfo[msg.sender];\\n    require(user.withdrawRequestBlock > 0, \\\"No request\\\");\\n    uint256 exitBlocks = EXIT_PERIOD / blockTime;\\n    require(block.number >= user.withdrawRequestBlock + exitBlocks, \\\"Exit not finished\\\");\\n\\n    uint256 amt = user.withdrawalAmount;\\n    require(amt > 0, \\\"No amount\\\");\\n\\n    // Effects\\n    user.amount       -= amt;\\n    totalStaked       -= amt;\\n    totalInExitPeriod -= amt;\\n\\n    user.withdrawRequestBlock = 0;\\n    user.withdrawalAmount     = 0;\\n\\n    if (user.amount == 0) {\\n      user.lockStartBlock     = 0;\\n      user.lockDurationBlocks = 0;\\n      user.lockDuration       = 0;\\n      user.effectiveAmount    = 0;\\n      user.rewardDebt         = 0;\\n    } else {\\n      user.rewardDebt = (user.effectiveAmount * accTokenPerShare) / PRECISION_FACTOR;\\n    }\\n\\n    _safeTransferNative(msg.sender, amt);\\n    emit WithdrawExecuted(msg.sender, amt);\\n  }\\n\\n  function cancelWithdraw() external {\\n    UserInfo storage user = userInfo[msg.sender];\\n    require(user.withdrawRequestBlock > 0, \\\"No request\\\");\\n\\n    _updatePool();\\n\\n    // Claim matured before restoring effective\\n    _claimRewardsInternal(msg.sender);\\n\\n    uint256 addEff = (user.withdrawalAmount * _getBoostMultiplier(user.lockDuration)) / 1e18;\\n    user.effectiveAmount += addEff;\\n    totalActiveEffective += addEff;\\n\\n    totalInExitPeriod       -= user.withdrawalAmount;\\n    user.withdrawRequestBlock = 0;\\n    user.withdrawalAmount     = 0;\\n\\n    user.rewardDebt = (user.effectiveAmount * accTokenPerShare) / PRECISION_FACTOR;\\n  }\\n\\n  // ---------------------------\\n  // Rewards\\n  // ---------------------------\\n  function claimRewards() external nonReentrant {\\n    _claimRewardsInternal(msg.sender);\\n  }\\n\\n  function _claimRewardsInternal(address _user) internal {\\n    UserInfo storage user = userInfo[_user];\\n\\n    // Compute VESTED frontier: accPS at (block - delay)\\n    uint256 delayBlocks = REWARD_DELAY_PERIOD / blockTime;\\n    uint256 tBlock = block.number > delayBlocks ? block.number - delayBlocks : 0;\\n    uint256 accPast = _accPSAtBlock(uint64(tBlock));\\n\\n    // Virtual owed since last claim baseline\\n    uint256 baseline = user.debtClaimablePS;\\n    uint256 virtualOwed = 0;\\n    if (accPast > baseline && user.effectiveAmount > 0) {\\n      virtualOwed = (user.effectiveAmount * (accPast - baseline)) / PRECISION_FACTOR;\\n    }\\n\\n    _updatePool();\\n\\n    uint256 owed = virtualOwed;\\n\\n    // Add snapshot from exiting portion if unlocked now\\n    if (user.delayedUnlockBlock > 0 && block.number >= user.delayedUnlockBlock) {\\n      owed += user.delayedReward;\\n      user.delayedReward = 0;\\n      user.delayedUnlockBlock = 0;\\n    }\\n\\n    uint256 budget = _rewardBalance();\\n    uint256 pay = owed <= budget ? owed : budget;\\n\\n    if (pay > 0) {\\n      _safeTransferNative(_user, pay);\\n      totalClaimedRewards += pay;\\n      emit RewardClaimed(_user, pay);\\n    }\\n\\n    // Advance claim baseline proportionally if underpaid\\n    if (owed > 0) {\\n      uint256 paidRatio = (pay * PRECISION_FACTOR) / owed;\\n      uint256 delta = accPast - baseline;\\n      uint256 advance = (paidRatio * delta) / PRECISION_FACTOR;\\n      user.debtClaimablePS = baseline + advance;\\n    } else {\\n      user.debtClaimablePS = accPast;\\n    }\\n\\n    // Keep rewardDebt synced for pending view\\n    user.rewardDebt = (user.effectiveAmount * accTokenPerShare) / PRECISION_FACTOR;\\n  }\\n\\n  // ---------------------------\\n  // Views\\n  // ---------------------------\\n  function pendingReward(address _user) public view returns (uint256) {\\n    UserInfo storage user = userInfo[_user];\\n    if (user.withdrawRequestBlock != 0) return 0;\\n\\n    uint256 active = _activeEffective();\\n    if (active == 0) return 0;\\n\\n    uint256 adjusted = accTokenPerShare;\\n    if (block.number > lastRewardBlock) {\\n      uint256 mult = block.number - lastRewardBlock;\\n      uint256 toAlloc = mult * rewardPerBlock;\\n\\n      uint256 undistributed = totalAccruedRewards - totalClaimedRewards;\\n      uint256 currentRewards = _rewardBalance();\\n      uint256 allocCap = currentRewards > undistributed ? (currentRewards - undistributed) : 0;\\n      if (toAlloc > allocCap) toAlloc = allocCap;\\n\\n      if (toAlloc > 0) {\\n        adjusted += (toAlloc * PRECISION_FACTOR) / active;\\n      }\\n    }\\n\\n    return ((user.effectiveAmount * adjusted) / PRECISION_FACTOR) - user.rewardDebt;\\n  }\\n\\n  // Pure read-only: what's claimable now from the sliding window + unlocked delayed snapshot\\n  function claimableView(address _user) external view returns (uint256) {\\n    UserInfo storage user = userInfo[_user];\\n    uint256 owed = 0;\\n\\n    // unlocked snapshot from exiting portion\\n    if (user.delayedUnlockBlock > 0 && block.number >= user.delayedUnlockBlock) {\\n      owed += user.delayedReward;\\n    }\\n\\n    // sliding window for current effective\\n    uint256 E = user.effectiveAmount;\\n    if (E == 0) return owed;\\n\\n    uint256 delayBlocks = REWARD_DELAY_PERIOD / blockTime;\\n    uint256 tBlock = block.number > delayBlocks ? block.number - delayBlocks : 0;\\n    uint256 accPast = _accPSAtBlock(uint64(tBlock));\\n    uint256 baseline = user.debtClaimablePS;\\n    if (accPast > baseline) {\\n      owed += (E * (accPast - baseline)) / PRECISION_FACTOR;\\n    }\\n    return owed;\\n  }\\n\\n  // How much has streamed but is still locked (inside the delay window) + locked snapshot\\n  function lockedView(address _user) external view returns (uint256) {\\n    UserInfo storage user = userInfo[_user];\\n    uint256 locked = 0;\\n\\n    // locked snapshot from exiting portion\\n    if (user.delayedUnlockBlock > 0 && block.number < user.delayedUnlockBlock) {\\n      locked += user.delayedReward;\\n    }\\n\\n    uint256 E = user.effectiveAmount;\\n    if (E == 0) return locked;\\n\\n    uint256 accNow = _accPSNowView();\\n    uint256 delayBlocks = REWARD_DELAY_PERIOD / blockTime;\\n    uint256 tBlock = block.number > delayBlocks ? block.number - delayBlocks : 0;\\n    uint256 accPast = _accPSAtBlock(uint64(tBlock));\\n    if (accNow > accPast) {\\n      locked += (E * (accNow - accPast)) / PRECISION_FACTOR;\\n    }\\n    return locked;\\n  }\\n\\n  function isLocked(address _user) external view returns (bool) {\\n    UserInfo storage user = userInfo[_user];\\n    if (user.lockStartBlock == 0) return false;\\n    return block.number < user.lockStartBlock + user.lockDurationBlocks;\\n  }\\n\\n  function isInExitPeriod(address _user) external view returns (bool) {\\n    return userInfo[_user].withdrawRequestBlock > 0;\\n  }\\n\\n  function getUserInfo(address _user)\\n    external\\n    view\\n    returns (\\n      uint256 stakedAmount,\\n      uint256 lockStartTime,\\n      uint256 lockEndTime,\\n      uint256 lockDuration,\\n      uint256 withdrawRequestTime,\\n      uint256 withdrawalAmount,\\n      uint256 withdrawalAvailableTime,\\n      bool isLocked_,\\n      bool inExitPeriod,\\n      bool canRequestWithdraw,\\n      bool canExecuteWithdraw\\n    )\\n  {\\n    UserInfo storage user = userInfo[_user];\\n    stakedAmount     = user.amount;\\n    lockDuration     = user.lockDuration;\\n    withdrawalAmount = user.withdrawalAmount;\\n\\n    lockStartTime       = user.lockStartBlock == 0 ? 0 : (block.timestamp - (block.number - user.lockStartBlock) * blockTime);\\n    withdrawRequestTime = user.withdrawRequestBlock == 0 ? 0 : (block.timestamp - (block.number - user.withdrawRequestBlock) * blockTime);\\n\\n    if (user.lockStartBlock > 0) {\\n      lockEndTime        = lockStartTime + lockDuration;\\n      isLocked_          = block.number < user.lockStartBlock + user.lockDurationBlocks;\\n      canRequestWithdraw = !isLocked_ && user.withdrawRequestBlock == 0;\\n    }\\n\\n    if (user.withdrawRequestBlock > 0) {\\n      inExitPeriod = true;\\n      uint256 exitBlocks = EXIT_PERIOD / blockTime;\\n      withdrawalAvailableTime = withdrawRequestTime + EXIT_PERIOD;\\n      canExecuteWithdraw      = block.number >= user.withdrawRequestBlock + exitBlocks;\\n    }\\n  }\\n\\n  function timeUntilUnlock(address _user) external view returns (uint256) {\\n    UserInfo storage user = userInfo[_user];\\n    if (user.lockStartBlock == 0) return 0;\\n    if (block.number >= user.lockStartBlock + user.lockDurationBlocks) return 0;\\n    uint256 remaining = user.lockStartBlock + user.lockDurationBlocks - block.number;\\n    return remaining * blockTime;\\n  }\\n\\n  function timeUntilWithdrawalAvailable(address _user) external view returns (uint256) {\\n    UserInfo storage user = userInfo[_user];\\n    if (user.withdrawRequestBlock == 0) return 0;\\n    uint256 exitBlocks = EXIT_PERIOD / blockTime;\\n    if (block.number >= user.withdrawRequestBlock + exitBlocks) return 0;\\n    uint256 remaining = user.withdrawRequestBlock + exitBlocks - block.number;\\n    return remaining * blockTime;\\n  }\\n\\n  function getUserStatus(address _user) external view returns (string memory) {\\n    UserInfo storage user = userInfo[_user];\\n    if (user.amount == 0) return \\\"No stake\\\";\\n    if (user.withdrawRequestBlock > 0) {\\n      uint256 exitBlocks = EXIT_PERIOD / blockTime;\\n      if (block.number >= user.withdrawRequestBlock + exitBlocks) return \\\"Withdrawal ready\\\";\\n      return \\\"In exit period\\\";\\n    }\\n    if (block.number < user.lockStartBlock + user.lockDurationBlocks) return \\\"Locked\\\";\\n    return \\\"Unlocked\\\";\\n  }\\n\\n  function getRewardBalance() external view returns (uint256) {\\n    return _rewardBalance();\\n  }\\n\\n  function getEstimatedAPY(uint256 _duration) public view returns (uint256) {\\n    if (_duration != 10 minutes && _duration != 20 minutes) return 0;\\n    uint256 activePrincipal = _activePrincipal();\\n    if (activePrincipal == 0) return 0;\\n    uint256 mult = _getBoostMultiplier(_duration);\\n    uint256 blocksPerYear = 365 days / blockTime;\\n    uint256 annualRewards = rewardPerBlock * blocksPerYear;\\n    uint256 base = (annualRewards * 10000) / activePrincipal; // basis points\\n    return (base * mult) / 1e18;\\n  }\\n\\n  function getBaseAPY() public view returns (uint256) {\\n    uint256 activePrincipal = _activePrincipal();\\n    if (activePrincipal == 0) return 0;\\n    uint256 blocksPerYear = 365 days / blockTime;\\n    uint256 annualRewards = rewardPerBlock * blocksPerYear;\\n    return (annualRewards * 10000) / activePrincipal;\\n  }\\n\\n  // ---------------------------\\n  // Reward accounting + checkpoints\\n  // ---------------------------\\n  function _updatePool() internal {\\n    if (block.number <= lastRewardBlock) return;\\n\\n    uint256 active = _activeEffective();\\n    if (active == 0) { lastRewardBlock = block.number; return; }\\n\\n    uint256 mult = block.number - lastRewardBlock;\\n    uint256 toAlloc = mult * rewardPerBlock;\\n\\n    uint256 undistributed = totalAccruedRewards - totalClaimedRewards;\\n    uint256 currentRewards = _rewardBalance();\\n    uint256 allocCap = currentRewards > undistributed ? (currentRewards - undistributed) : 0;\\n    if (toAlloc > allocCap) toAlloc = allocCap;\\n\\n    if (toAlloc > 0) {\\n      accTokenPerShare += (toAlloc * PRECISION_FACTOR) / active;\\n      totalAccruedRewards += toAlloc;\\n    }\\n    lastRewardBlock = block.number;\\n\\n    // periodic checkpoint\\n    if (uint64(block.number) - lastCheckpointBlock >= checkpointInterval) {\\n      _pushCheckpoint(uint64(block.number), accTokenPerShare);\\n      lastCheckpointBlock = uint64(block.number);\\n    }\\n  }\\n\\n  function _accPSNowView() internal view returns (uint256) {\\n    uint256 active = _activeEffective();\\n    if (active == 0) return accTokenPerShare;\\n    if (block.number <= lastRewardBlock) return accTokenPerShare;\\n\\n    uint256 mult = block.number - lastRewardBlock;\\n    if (mult == 0) return accTokenPerShare;\\n\\n    uint256 toAlloc = mult * rewardPerBlock;\\n    uint256 undistributed = totalAccruedRewards - totalClaimedRewards;\\n    uint256 currentRewards = _rewardBalance();\\n    uint256 allocCap = currentRewards > undistributed ? (currentRewards - undistributed) : 0;\\n    if (toAlloc > allocCap) toAlloc = allocCap;\\n    if (toAlloc == 0) return accTokenPerShare;\\n\\n    return accTokenPerShare + (toAlloc * PRECISION_FACTOR) / active;\\n  }\\n\\n  // Interpolated accPS at a past block (for sliding-window vesting)\\n  function _accPSAtBlock(uint64 targetBlock) internal view returns (uint256) {\\n    if (_cpSize == 0) return 0;\\n\\n    // Find bracketing checkpoints: prev <= target < next\\n    (bool hasPrev, Checkpoint memory prev) = _findPrevCp(targetBlock);\\n    (bool hasNext, Checkpoint memory next_) = _findNextCp(prev.blockNum);\\n\\n    if (!hasPrev) return 0;\\n    if (!hasNext || targetBlock >= next_.blockNum) {\\n      // no next (or target beyond next) \\u2192 just prev\\n      // If target > lastRewardBlock we also need to pro-rate dormant batch\\n      if (targetBlock > lastRewardBlock) {\\n        // prorate since lastRewardBlock\\n        uint256 active = _activeEffective();\\n        if (active == 0) return prev.acc;\\n        uint256 fullDelta = uint256(block.number) - lastRewardBlock;\\n        if (fullDelta == 0) return prev.acc;\\n\\n        uint256 blockToTarget = uint256(targetBlock) - lastRewardBlock;\\n        if (blockToTarget > fullDelta) blockToTarget = fullDelta;\\n\\n        uint256 undistributed = totalAccruedRewards - totalClaimedRewards;\\n        uint256 currentRewards = _rewardBalance();\\n        uint256 allocCap = currentRewards > undistributed ? (currentRewards - undistributed) : 0;\\n\\n        uint256 fullToAlloc = rewardPerBlock * fullDelta;\\n        if (fullToAlloc > allocCap) fullToAlloc = allocCap;\\n\\n        uint256 prorata = (fullToAlloc * blockToTarget) / fullDelta;\\n        return prev.acc + (prorata * PRECISION_FACTOR) / active;\\n      }\\n      return prev.acc;\\n    }\\n\\n    // interpolate between prev and next\\n    if (next_.blockNum == prev.blockNum) return prev.acc;\\n    uint256 span = next_.blockNum - prev.blockNum;\\n    uint256 into = targetBlock - prev.blockNum;\\n    uint256 deltaAcc = next_.acc - prev.acc;\\n    return prev.acc + (deltaAcc * into) / span;\\n  }\\n\\n  function _findPrevCp(uint64 target) internal view returns (bool, Checkpoint memory) {\\n    uint16 idx = _cpHead;\\n    uint16 count = 0;\\n    Checkpoint memory best;\\n    bool ok = false;\\n    while (count < _cpSize) {\\n      Checkpoint memory cp = _checkpoints[idx];\\n      if (cp.blockNum != 0 && cp.blockNum <= target && (!ok || cp.blockNum >= best.blockNum)) {\\n        best = cp; ok = true;\\n      }\\n      if (idx == 0) idx = MAX_CHECKPOINTS - 1; else idx--;\\n      count++;\\n    }\\n    return (ok, best);\\n  }\\n\\n  function _findNextCp(uint64 prevBlock) internal view returns (bool, Checkpoint memory) {\\n    // Scan forward from oldest to newest to find the next > prevBlock\\n    uint16 count = 0;\\n    // First, find oldest index\\n    uint16 oldest = _cpHead + MAX_CHECKPOINTS + 1 - _cpSize;\\n    oldest %= MAX_CHECKPOINTS;\\n    // Walk forward oldest \\u2192 head\\n    uint16 i = oldest;\\n    while (count < _cpSize) {\\n      Checkpoint memory cp = _checkpoints[i];\\n      if (cp.blockNum > prevBlock) return (true, cp);\\n      if (i == _cpHead) break;\\n      i = (i + 1) % MAX_CHECKPOINTS;\\n      count++;\\n    }\\n    return (false, Checkpoint({blockNum:0, acc:0}));\\n  }\\n\\n  function _pushCheckpoint(uint64 blockNum, uint256 acc) internal {\\n    uint16 next = _cpHead + 1;\\n    if (next >= MAX_CHECKPOINTS) next = 0;\\n    _checkpoints[next] = Checkpoint({ blockNum: blockNum, acc: acc });\\n    _cpHead = next;\\n    if (_cpSize < MAX_CHECKPOINTS) _cpSize++;\\n  }\\n\\n  // ---------------------------\\n  // Admin\\n  // ---------------------------\\n  function updatePeriods(uint256 _rewardDelayPeriod, uint256 _exitPeriod) external onlyOwner {\\n    _updatePool();\\n    require(_rewardDelayPeriod > 0 && _exitPeriod > 0, \\\"Invalid periods\\\");\\n    REWARD_DELAY_PERIOD = _rewardDelayPeriod;\\n    EXIT_PERIOD         = _exitPeriod;\\n    emit PeriodsUpdated(_rewardDelayPeriod, _exitPeriod);\\n  }\\n\\n  function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\\n    require(_tokenAddress != address(0), \\\"native not recoverable\\\");\\n    (bool success, ) = _tokenAddress.call(\\n      abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", msg.sender, _tokenAmount)\\n    );\\n    require(success, \\\"Token transfer failed\\\");\\n    emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\\n  }\\n\\n  function updatePoolLimitPerUser(bool _hasUserLimit, uint256 _poolLimitPerUser) external onlyOwner {\\n    _updatePool();\\n    if (_hasUserLimit) {\\n      require(!hasUserLimit || _poolLimitPerUser > poolLimitPerUser, \\\"Limit must increase\\\");\\n      hasUserLimit = true;\\n      poolLimitPerUser = _poolLimitPerUser;\\n    } else {\\n      hasUserLimit = false;\\n      poolLimitPerUser = 0;\\n    }\\n    emit NewPoolLimit(poolLimitPerUser);\\n  }\\n\\n  function fundRewards() external payable onlyOwner {\\n    require(msg.value > 0, \\\"No value\\\");\\n    emit RewardsFunded(msg.value);\\n  }\\n\\n  function emergencyRewardWithdraw(uint256 _amount) external onlyOwner {\\n    _updatePool();\\n    uint256 rb = _rewardBalance();\\n    require(_amount <= rb, \\\"Cannot withdraw principal\\\");\\n    _safeTransferNative(msg.sender, _amount);\\n  }\\n\\n  function setBaseAPY(uint256 _apyBps) external onlyOwner {\\n    _updatePool();\\n    require(_apyBps <= 1000000, \\\"APY too high\\\"); // up to 10000%\\n    uint256 activePrincipal = _activePrincipal();\\n    uint256 blocksPerYear   = 365 days / blockTime;\\n    if (activePrincipal > 0) {\\n      rewardPerBlock = (activePrincipal * _apyBps) / (blocksPerYear * 10000);\\n    } else {\\n      rewardPerBlock = (1e18 * _apyBps) / (blocksPerYear * 10000);\\n    }\\n    emit NewRewardPerBlock(rewardPerBlock);\\n  }\\n\\n  function setRewardPerBlock(uint256 _rewardPerBlock) external onlyOwner {\\n    _updatePool();\\n    rewardPerBlock = _rewardPerBlock;\\n    emit NewRewardPerBlock(_rewardPerBlock);\\n  }\\n\\n  function updateBlockTime(uint256 _newBlockTime) external onlyOwner {\\n    require(_newBlockTime > 0 && _newBlockTime <= 60, \\\"Bad blockTime\\\");\\n    uint256 old = blockTime;\\n    blockTime = _newBlockTime;\\n    emit BlockTimeUpdated(old, _newBlockTime);\\n  }\\n\\n  // ---------------------------\\n  // Misc\\n  // ---------------------------\\n  function updatePool() external { _updatePool(); }\\n\\n  function _safeTransferNative(address _to, uint256 _amount) internal {\\n    (bool success, ) = _to.call{ value: _amount }(\\\"\\\");\\n    require(success, \\\"Native transfer failed\\\");\\n  }\\n\\n  receive() external payable {}\\n  fallback() external payable {}\\n}\\n\",\"keccak256\":\"0xac4dceb9e2cae638d11c6c581ce377dc3a1c80abcb1ecdfab0af01ef435813e9\",\"license\":\"MIT\"}},\"version\":1}"